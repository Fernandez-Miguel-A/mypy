-- Test cases for user-defined plugins
--
-- Note: Plugins used by tests live under test-data/unit/plugins. Defining
--       plugin files in test cases does not work reliably.

[case testFunctionPlugin]
# flags: --config-file tmp/mypy.ini
def f() -> str: ...
reveal_type(f())  # E: Revealed type is 'builtins.int'
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/fnplugin.py

[case testTwoPlugins]
# flags: --config-file tmp/mypy.ini
def f(): ...
def g(): ...
def h(): ...
reveal_type(f())  # E: Revealed type is 'builtins.int'
reveal_type(g())  # E: Revealed type is 'builtins.str'
reveal_type(h())  # E: Revealed type is 'Any'
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/fnplugin.py,
  <ROOT>/test-data/unit/plugins/plugin2.py

[case testMissingPlugin]
# flags: --config-file tmp/mypy.ini
[file mypy.ini]
[[mypy]
plugins=missing.py
[out]
tmp/missing.py:0: error: Can't find plugin
--' (work around syntax highlighting)

[case testInvalidPluginExtension]
# flags: --config-file tmp/mypy.ini
[file mypy.ini]
[[mypy]
plugins=badext.pyi
[file badext.pyi]
[out]
tmp/badext.pyi:0: error: Plugin must have .py extension

[case testMissingPluginEntryPoint]
# flags: --config-file tmp/mypy.ini
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/noentry.py
[out]
<ROOT>/test-data/unit/plugins/noentry.py:0: error: Plugin does not define entry point function "plugin"

[case testInvalidPluginEntryPointReturnValue]
# flags: --config-file tmp/mypy.ini
def f(): pass
f()
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/badreturn.py
[out]
<ROOT>/test-data/unit/plugins/badreturn.py:0: error: Type object expected as the return value of "plugin" (got None)

[case testInvalidPluginEntryPointReturnValue2]
# flags: --config-file tmp/mypy.ini
def f(): pass
f()
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/badreturn2.py
[out]
<ROOT>/test-data/unit/plugins/badreturn2.py:0: error: Return value of "plugin" must be a subclass of "mypy.plugin.Plugin"

[case testAttributeTypeHookPlugin]
# flags: --config-file tmp/mypy.ini
from typing import Callable
from m import Signal
s: Signal[Callable[[int], None]] = Signal()
s(1)
s('') # E: Argument 1 has incompatible type "str"; expected "int"
[file m.py]
from typing import TypeVar, Generic, Callable
T = TypeVar('T', bound=Callable[..., None])
class Signal(Generic[T]):
    __call__: Callable[..., None]
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/attrhook.py

[case testTypeAnalyzeHookPlugin]
# flags: --config-file tmp/mypy.ini
from typing import Callable
from mypy_extensions import DefaultArg
from m import Signal
s: Signal[[int, DefaultArg(str, 'x')]] = Signal()
reveal_type(s) # E: Revealed type is 'm.Signal[def (builtins.int, x: builtins.str =)]'
s.x # E: Signal[Callable[[int, str], None]] has no attribute "x"
ss: Signal[int, str] # E: Invalid "Signal" type (expected "Signal[[t, ...]]")
[file m.py]
from typing import TypeVar, Generic, Callable
T = TypeVar('T', bound=Callable[..., None])
class Signal(Generic[T]):
    __call__: Callable[..., None]
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/type_anal_hook.py
[builtins fixtures/dict.pyi]

[case testFunctionPluginHookForReturnedCallable]
# flags: --config-file tmp/mypy.ini
from m import decorator1, decorator2
@decorator1()
def f() -> None: pass
@decorator2()
def g() -> None: pass
reveal_type(f) # E: Revealed type is 'def (*Any, **Any) -> builtins.str'
reveal_type(g) # E: Revealed type is 'def (*Any, **Any) -> builtins.int'
[file m.py]
from typing import Callable
def decorator1() -> Callable[..., Callable[..., int]]: pass
def decorator2() -> Callable[..., Callable[..., int]]: pass
[file mypy.ini]
[[mypy]
plugins=<ROOT>/test-data/unit/plugins/named_callable.py
